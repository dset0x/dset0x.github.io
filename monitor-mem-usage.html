<!DOCTYPE html>
<html lang="en" xml:lang="en">
<head>
    <title>Monitoring memory usage for weechat script leaks - When software gets in the way</title>
    <meta charset="utf-8">
    <meta name="description" content="Monitoring memory usage for weechat script leaks">
    <meta name="keywords" content="weechat,linux,memory_leak,script">
    <meta name="author" content="Dimitrios Semitsoglou-Tsiapos">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
    <link rel="alternate" type="application/rss+xml" title="When software gets in the way" href="/feed.xml" />
    <style>
        /* General */
        html        {background-color: #fffdff;}
        body        {font-family: sans-serif; max-width: 79ch; opacity: 0.85;}
        a           {text-decoration: none;}
        a:link      {color: #3189c5;}
        a:visited   {color: #a131c5;}
        a:hover     {text-decoration: underline;}

        /* Headings */
        h2      {font-size: medium; margin: 0.67em 0 0.67em 0; font-weight: initial;}
        h1      {font-size: large; text-align: center;}

        /* Previews */
        article .preview {max-height: 20vw; overflow:hidden; opacity: 0.9; margin-left: 4ch;}

        /* Preview cont */
        article .preview {position: relative; text-align: justify;}
        article .preview .cont {position: absolute; bottom: 0; right: 0; background: #fffdff; font-size: small; box-shadow: 0px 0px 0.5ch 0.5ch white;}

        /* Menu */
        ul                  {padding-left: 0;}
        ul#menu li:before   {content: '［';}
        ul#menu li:after    {content: '］';}

            /* Centered */
                ul#menu                         {text-align: center; margin: 0;}
                ul#menu li                      {display: block;}
                ul#menu li:not(last-child)      {padding: 0.2em 0 0.2em 0;}

            /* Not centered */
                /* ul#menu li                   {display: inline;} */
                /* ul#menu li:not(last-child)   {padding-right: 1ch;} */

        /* Code on mobile */
        @media (max-width: 65ch) { pre {overflow: scroll;} }

        /* Skip to content */
        .skip {position: absolute; opacity:0; pointer-events: none;}
        .skip:active, .skip:focus {opacity:1;}
    </style>
</head>
<body>

<a href="#content" class="skip" tabindex="1">Skip to content</a></div>
<nav>
    <ul id="menu">
        <li><a href="/">Home</a></li>
        <li><a href="https://github.com/search?o=desc&q=author:dset0x+&s=created&type=Issues&utf8=✓">GitHub Issues</a></li>
    </ul> 
    <hr>
</nav>

<main id="content">
<article>
<h1><a name="section_1">Monitoring memory usage for weechat script leaks</a></h1>

<p>I was recently dealing with a memory leak within a script in `weechat`. I
needed a quick and dirty way of figuring out which script was causing the
trouble.
</p>
<p>Of course it makes no sense to use `awk` for this, but what the heck. This
script unloads all weechat scripts, then loads them one at a time whenever
passed a line.
</p>
<pre>
    #!/usr/bin/env awk -f

    function load(scr) {
        print strftime("%s"), scr
        system("echo -e \*/script load "scr" &gt; ~/.weechat/weechat\_fifo_$(pgrep --exact weechat)")
    }

    function unload(scr) {
        system("echo -e \*/script unload "scr" &gt; ~/.weechat/weechat\_fifo_$(pgrep --exact weechat)")
    }

    BEGIN {
        "echo ~/.weechat/**/autoload/*" | getline script_paths_str
        split(script_paths_str, script_paths, " ")
        for(idx in script_paths) {
            len = split(script_paths[idx], _, "/")
            script_names[idx] = _[len]
            unload(script_names[idx])
        }
    }

    // {
        if(NR&gt;=1) {
            if(cur_script != "") {
                    unload(cur_script)
            }

            cur_script = script_names[NR+1]
            load(cur_script)
        }
    }

    END {
        for(idx in script_names) {
            load(script_names[idx])
        }
    }
</pre>
<p>We can go ahead and load one script every one hour:
</p>
<pre>
    $ while :; do echo 1; sleep 1h; done | ./above_script.awk &gt; /tmp/events
</pre>
<p>Now we have a bunch of timestamped events, but we'd like to frequently check
memory usage too. Let's have another loop do that for us.
</p>
<pre>
    $ while :; do echo $(date +%s) $(ps -q $(pgrep --exact weechat) -o rss,vsz | tail -n 1) &gt;&gt; /tmp/mem; sleep 5s; done
</pre>
<p>Now to graph everything into a readable image we can use `gnuplot`:
</p>
<pre>
    #!/bin/bash
    {
        cat &lt;&lt;EOF
        set term png small size 1900,600
        set output "/tmp/mem-graph.png"

        set ylabel "RSS (mb)"
        set y2label "VSZ (mb)"

        set ytics nomirror
        set y2tics nomirror in
        set grid ytics lc rgb "#bbbbbb" lw 1 lt 0

        set yrange [230.000:*]
        set y2range [90.000:*]

        set tic scale 0
        set xtics format " "
        set xtics rotate by 45 offset -0.8,-9.8
        set bmargin 11

    EOF
        cat /tmp/events | while read date ev_name; do
            echo "set arrow from $date, graph 0 to $date, graph 1 nohead"
            echo "set xtics add (\""$ev_name"\" $date)"
        done

        cat &lt;&lt;EOF
        plot "&lt; uniq -f 0 /tmp/mem" using 1:(\$3/1000) with lines axes x1y1 title "VSZ", \
             "&lt; uniq -f 0 /tmp/mem" using 1:(\$2/1000) with lines axes x1y2 title "RSS"
    EOF
    } | gnuplot
</pre>
<p>What's handy about this setup is that we can kill any script for any reason
without losing data. In fact we can stop the first one and load whichever
scripts we want, as long as we maintain `/tmp/events`.
</p>
<p>Of course you can run the `gnuplot` script on a remote box as long as you have
access to the two logfiles.
</p>
<pre>
    $ rifle <a href="/opt/mCeOgNe.png">/tmp/mem-graph.png</a>
</pre></article>
</main>
<footer>
</footer>
</body>
</html>
